# 1 volatile

volatile是轻量级的synchronized，它在多处理器开发中保证了**共享变量的“可见性”。**可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果volatile变量修饰符使用恰当的话，它比synchronized的**使用和执行成本更低，因为它不会引起线程上下文的切换和调度**。

![CPU的术语定义](.\pic\CPU的术语定义.png)

**volatile的定义与实现原理**：

如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存.

Lock前缀的指令在多核处理器下会引发了两件事:

1）将当前处理器缓存行的数据写回到系统内存。

2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。

**如果其他处理器缓存的值还是旧的**，再执行计算操作就会有问题。

解决方法：

>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

volatile的两条实现原则:

1）**Lock前缀指令会引起处理器缓存回写到内存**。LOCK #信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。它会锁定这块内存区域的缓存并回写到内存，并**使用缓存一致性机制来确保修改的原子性**，此操作被称为“缓存锁定”，**缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据**。

2）**一个处理器的缓存回写到内存会导致其他处理器的缓存无效**。嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。

优化： 追加字节。L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，**如果队列的头节点和尾节点都不足64字节的话**，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。

**那么是不是在使用volatile变量时都应该追加到64字节呢？**

- 缓存行非64字节宽的处理器。
- 共享变量不会被频繁地写。

# 2 synchronized的实现原理与应用

在多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。Java SE 1.6中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。

Java中的每一个对象都可以作为锁。具体表现为以下3种形式：

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
-  对于同步方法块，锁是Synchonized括号里配置的对象。

> 实例对象和class对象的区别。

**JVM基于进入和退出Monitor对象来实现方法同步和代码块同步**，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的。

JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，**当且一个monitor被持有后，它将处于锁定状态。**线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

## 2.1 Java对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit.

![对象头](.\pic\对象头.png)

在64位虚拟机下，Mark Word是64bit大小的，其存储结构如表所示。

![64位对象头](.\pic\64位对象头.png)

## 2.2 锁的升级与对比

Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着**偏向锁升级成轻量级锁后不能降级成偏向锁**。这种锁升级却不能降级的策略，**目的是为了提高获得锁和释放锁的效率**.

### **2.2.1 偏向锁:**

锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。一个线程访问同步块并获取锁时，**会在对象头和栈帧中的锁记录里存储锁偏向的线程ID**，以后该线程在进入和退出同步块时不需要**进行CAS操作来加锁和解锁**，只需简单地**测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁**。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再**测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁**）：**如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。**

**偏向锁的撤销**: 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

**关闭偏向锁**: 可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。

### 2.2.2 轻量级锁

1）**轻量级锁加锁**.线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

**2）轻量级锁解锁时**，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。

**因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。**

![偏向锁初始化流程](.\pic\偏向锁初始化流程.png)

### 2.2.3 锁的优缺点对比

![锁的优缺点](.\pic\锁的优缺点.png)

# 3 原子操作的实现原理

**处理器如何实现原子操作**：

- 使用总线锁保证原子性(总线锁就是使用处理器提供的一个LOCK #信号，**当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住**，那么该处理器可以独占共享内存。开销较大)

- 使用缓存锁保证原子性。（缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效）

有两种情况下处理器不会使用缓存锁定：

- 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cacheline）时，则处理器会调用总线锁定。
- 有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。

**Java如何实现原子操作**：

- 使用循环CAS实现原子操作，CAS实现原子操作的三大问题：
  - ABA问题。
  - 循环时间长开销大。
  - 只能保证一个共享变量的原子操作
- 使用锁机制实现原子操作（锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。）