### 内存布局

1.7 内存布局

![1.7虚拟机运行时数据区](.\pic\1.7虚拟机运行时数据区.png)

1.8 内存布局

![1.8jvm内存布局](.\pic\1.8jvm内存布局.png)

从1.7开始 java 逐渐移除永久代（字符串常量池移除永久代），1.8 方法区变为元数据区。

```
拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。
为什么将永久代移除？
1.对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。
2.类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。
3.JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误。在JDK8中，字符串常量池中只保存字符串的引用。
4.永久代的GC带来不必要的复杂度，回收效率很低。
```

####  Heap （堆区）

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。通过如下参数设定初始值和最大值，比如 －Xms256M -Xmx1024M。但是 在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力 ， 所以在线上生产环境中 ， JVM 的 Xms 和 Xmx 设置成 样大小，避免在 GC 后调整堆大小时带来的额外压力。

堆分成两大块 新生代和老年代。新生代＝ 1 个 Eden 区＋ 2 个 Survivor 区。绝大部分对象在 Eden 区生成 ， 当 Eden 区装填满的时候 ， 会触发 Young Garbage Collection ， 即 YGC。垃圾回收的时候 ， 在 Eden 区实现清除策略 ，没有被引 用的对象则直接回收。依**然存活的对象会被移送到 Survivor 区** ， 这个区真是名副其 实的存在。 Survivor 区分为 S0和 Sl 两块内存空间 ， 送到哪块空间呢？每次 YGC 的 时候， 它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除 ， 交换两块空间的使用状态。如果 YGC 要移送的对象大于 Survivor 区容量的 上限，则直接移交给老年代。每个对象都有一个计数器，每次 YGC 都会加 l 。 －XX:MaxTenuringThreshold 参数能配置计数器的值到达某个阐值的时候， 对象从 新生代晋升至老年代。如果该参数配置为 I ，那么从新生代的 Eden 区直接移至老年代。 默认值是 15 ， 可以在 Survivor 区交换 14 次之后 ， 晋升至老年代。

![YGC](.\pic\YGC.png)

