### 内存布局

### 1.7 内存布局

![1.7虚拟机运行时数据区](.\pic\1.7虚拟机运行时数据区.png)

### 1.8 内存布局

![1.8jvm内存布局](.\pic\1.8jvm内存布局.png)

从1.7开始 java 逐渐移除永久代（字符串常量池移除永久代），1.8 方法区变为元数据区。

```
拟机团队在JDK8的HotSpot中，把永久代从Java堆中移除了，并把类的元数据直接保存在本地内存区域（堆外内存），称之为元空间。
为什么将永久代移除？
1.对永久代的调优过程非常困难，永久代的大小很难确定，其中涉及到太多因素，如类的总数、常量池大小和方法数量等，而且永久代的数据可能会随着每一次Full GC而发生移动。
2.类的元数据保存在本地内存中，元空间的最大可分配空间就是系统可用内存空间，可以避免永久代的内存溢出问题，不过需要监控内存的消耗情况，一旦发生内存泄漏，会占用大量的本地内存。
3.JDK7之前的HotSpot，字符串常量池的字符串被存储在永久代中，因此可能导致一系列的性能问题和内存溢出错误。在JDK8中，字符串常量池中只保存字符串的引用。
4.永久代的GC带来不必要的复杂度，回收效率很低。
```

####  Heap （堆区）

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。通过如下参数设定初始值和最大值，比如 －Xms256M -Xmx1024M。但是 在通常情况下，服务器在运行过程中，堆空间不断地扩容与回缩，势必形成不必要的系统压力 ， 所以在线上生产环境中 ， JVM 的 Xms 和 Xmx 设置成 样大小，避免在 GC 后调整堆大小时带来的额外压力。

堆分成两大块 新生代和老年代。新生代＝ 1 个 Eden 区＋ 2 个 Survivor 区。绝大部分对象在 Eden 区生成 ， 当 Eden 区装填满的时候 ， 会触发 Young Garbage Collection ， 即 YGC。垃圾回收的时候 ， 在 Eden 区实现清除策略 ，没有被引 用的对象则直接回收。依**然存活的对象会被移送到 Survivor 区** ， 这个区真是名副其 实的存在。 Survivor 区分为 S0和 Sl 两块内存空间 ， 送到哪块空间呢？每次 YGC 的 时候， 它们将存活的对象复制到未使用的那块空间，然后将当前正在使用的空间完全清除 ， 交换两块空间的使用状态。如果 YGC 要移送的对象大于 Survivor 区容量的 上限，则直接移交给老年代。每个对象都有一个计数器，每次 YGC 都会加 l 。 －XX:MaxTenuringThreshold 参数能配置计数器的值到达某个阐值的时候， 对象从 新生代晋升至老年代。如果该参数配置为 I ，那么从新生代的 Eden 区直接移至老年代。 默认值是 15 ， 可以在 Survivor 区交换 14 次之后 ， 晋升至老年代。

![YGC](.\pic\YGC.png)

如果 Survivor 区无法放下，或者超大对象的闹值超过上限，贝lj 尝试 在老年代中进行分配 ； 如果老年代也无法放下，贝lj会触发 Full Garbage Collection ， 即 FGC。如果依然无法放下， 则抛出 OOM。堆内存出现 OOM 的概率是所有内存耗尽 异常中最高的。出错时的堆内信息对解决问题非常有帮助 ， 所以给NM设置运行参 数 －XX:+HeapDumpOnOutOfMemoryError，让口瓜4 遇到 OOM异常时能输出堆内信息， 特别是对相隔数月才出现的 OOM 异常尤为重要。

### Metaspace （元空间）

早在 JDK8 版本中，无空间的前身 Perm 区已经被淘汰。在 JDK7 及之前的版本中，只有 Hotspot 才有 Perm 区，译为永久代 ， 它在启动时固定大小，很难进行调优，并且 FGC 时会移 动类无信息。在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。

JDK8 里， Perm 区中的所有内容 中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等 都移动至无空间内，比如图 4-10 中的 0均ect 类元信息、静态属性 System.out、整型常量 10000000 等。图 4-10 中显示在常量池中的 Strir毡， 其实际对象是被保存在堆内 存中的。

### JVM Stack ( 虚拟机栈）