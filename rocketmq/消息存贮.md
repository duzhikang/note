## 1 存储概要设计

RocketMQ主要存储的文件包括Comitlog文件、ConsumeQueue文件、IndexFile文件。

RocketMQ将所有主题的消息存储在同一个文件中，确保消息发送时顺序写文件，尽最大的能力确保消息发送的高性能与高吞吐量。但由于消息中间件一般是基于消息主题的订阅机制，这样便给按照消息主题检索消息带来了极大的不便。为了提高消息消费的效率，**RocketMQ引入了ConsumeQueue消息队列文件，每个消息主题包含多个消息消费队列，每一个消息队列有一个消息文件**。IndexFile索引文件，其主要设计理念就是为了**加速消息的检索性能，**根据消息的属性快速从Commitlog文件中检索消息。RocketMQ是一款高性能的消息中间件，存储部分的设计是核心，存储的核心是**IO访问性能**。

RocketMQ消息存储设计原理图

![RocketMQ消息存储设计原理图](.\pic\RocketMQ消息存储设计原理图.jpg)

1）CommitLog：消息存储文件，所有消息主题的消息都存储在CommitLog文件中。

2）ConsumeQueue：消息消费队列，消息到达CommitLog文件后，**将异步转发到消息消费队列，供消息消费者消费**。

3）IndexFile：消息索引文件，主要存储消息Key与Offset的对应关系。

4）事务状态服务：存储每条消息的事务状态。

5）定时消息服务：每一个延迟级别对应一个消息消费队列，存储延迟队列的消息拉取进度。

## 2 初识消息存储

消息存储实现类：`org.apache.rocketmq.store.DefaultMessageStore`，它是存储模块里面最重要的一个类，包含了很多对存储文件操作的API，其他模块对消息实体的操作都是通过`DefaultMessageStore`进行操作

## 3 消息发送存储流程

消息存储入口：`org.apache.rocketmq.store.DefaultMessageStore#putMessage。`

Step1：如果当前Broker停止工作或Broker为SLAVE角色或当前Rocket不支持写入则拒绝消息写入；如果消息主题长度超过256个字符、消息属性长度超过65536个字符将拒绝该消息写入。

**日志中包含“message store is not writeable, so putMessage is forbidden”，出现这种日志最有可能是磁盘空间不足**

Step2：如果消息的延迟级别大于0，将消息的原主题名称与原消息队列ID存入消息属性中，用延迟消息主题SCHEDULE_TOPIC、消息队列ID更新原先消息的主题与队列，这是并发消息消费重试关键的一步.

Step3：获取当前可以写入的Commitlog文件.

![CommitLog文件组织方式](.\pic\CommitLog文件组织方式.jpg)

Commitlog文件存储目录为${ROCKET_HOME}/store/commitlog目录**，每一个文件默认1G**，一个文件写满后再创建另外一个，以该文件中第一个偏移量为文件名，偏移量小于20位用0补齐。图4-3所示的第一个文件初始偏移量为0，第二个文件的1073741824，代表该文件中的第一条消息的物理偏移量为1073741824，这样根据物理偏移量**能快速定位到消息**。MappedFileQueue可以看作是${ROCKET_HOME}/store/commitlog文件夹，而MappedFile则对应该文件夹下一个个的文件。

Step4：在写入CommitLog之前，先申请putMessageLock，也就是将消息存储到CommitLog文件中是**串行的。**

Step5：设置消息的存储时间，如果mappedFile为空，表明${ROCKET_HOME}/store/commitlog目录下不存在任何文件，说明本次消息是第一次消息发送，用偏移量0创建第一个commit文件，文件为00000000000000000000，如果文件创建失败，抛出CREATE_MAPEDFILE_FAILED，**很有可能是磁盘空间不足或权限不够。**

Step6：将消息追加到MappedFile中。首先先获取MappedFile当前写指针，如果currentPos大于或等于文件大小则表明文件已写满，抛出AppendMessageStatus.UNKNOWN_ERROR。如果currentPos小于文件大小，通过slice（）方法创建一个与MappedFile的共享内存区，并设置position为当前指针。

Step7：创建全局唯一消息ID，消息ID有16字节.

Step8：获取该消息在消息队列的偏移量。CommitLog中保存了当前所有消息队列的当前待写入偏移量。

Step9：根据消息体的长度、主题的长度、属性的长度结合消息存储格式计算消息的总长度。

RocketMQ消息存储格式如下。

1）TOTALSIZE：该消息条目总长度，4字节。

2）MAGICCODE：魔数，4字节。固定值0xdaa320a7。

3）BODYCRC：消息体crc校验码，4字节。

4）QUEUEID：消息消费队列ID,4字节。

5）FLAG：消息FLAG, RocketMQ不做处理，供应用程序使用，默认4字节。

6）QUEUEOFFSET：消息在消息消费队列的偏移量，8字节。

7）PHYSICALOFFSET：消息在CommitLog文件中的偏移量，8字节。

8）SYSFLAG：消息系统Flag，例如是否压缩、是否是事务消息等，4字节。

9）BORNTIMESTAMP：消息生产者调用消息发送API的时间戳，8字节。

10）BORNHOST：消息发送者IP、端口号，8字节。

11）STORETIMESTAMP：消息存储时间戳，8字节。

12）STOREHOSTADDRESS:Broker服务器IP+端口号，8字节。

13）RECONSUMETIMES：消息重试次数，4字节。

14）Prepared Transaction Offset：事务消息物理偏移量，8字节。

15）BodyLength：消息体长度，4字节。

16）Body：消息体内容，长度为bodyLenth中存储的值。

17）TopicLength：主题存储长度，1字节，表示主题名称不能超过255个字符。

18）Topic：主题，长度为TopicLength中存储的值。

19）PropertiesLength：消息属性长度，2字节，表示消息属性长度不能超过65536个字符。

20）Properties：消息属性，长度为PropertiesLength中存储的值。

```
INFO com.rudy.demo.SqlDemo - send result === SendResult [sendStatus=SEND_OK, msgId=C0A81F0D2F2418B4AAC28F4CC4AA0000, offsetMsgId=C0A81EBC00002A9F0000000000014738, messageQueue=MessageQueue [topic=Topic_A, brokerName=broker-a, queueId=8], queueOffset=24]


```

Step10：如果**消息长度+END_FILE_MIN_BLANK_LENGTH大于CommitLog文件的空闲空间**，则返回AppendMessageStatus.END_OF_FILE, Broker会重新创建一个新的CommitLog文件来存储该消息。从这里可以看出，每个CommitLog文件最少会空闲8个字节，高4字节存储当前文件剩余空间，低4字节存储魔数：CommitLog.BLANK_MAGIC_CODE。

Step11：将消息内容存储到ByteBuffer中，然后创建AppendMessageResult。这里只是将消息存储在MappedFile对应的内存映射Buffer中，**并没有刷写到磁盘，**

Step12：更新消息队列逻辑偏移量。

Step13：处理完消息追加逻辑后将释放putMessageLock锁。

Step14:DefaultAppendMessageCallback#doAppend只是将消息追加在内存中，需要根据是同步刷盘还是异步刷盘方式，将内存中的数据持久化到磁盘。

## 4 存储文件组织与内存映射

RocketMQ通过使用**内存映射文件来提高IO访问性能**，无论是CommitLog、ConsumeQueue还是IndexFile，单个文件都被设计为固定长度，如果一个文件写满以后再创建一个新文件，文件名就为该文件第一条消息对应的全局物理偏移量。

RocketMQ使用MappedFile、MappedFileQueue来封装存储文件，

### 4.1 MappedFileQueue映射文件队列

MappedFileQueue是MappedFile的管理容器，MappedFileQueue是对存储目录的封装，例如CommitLog文件的存储路径${ROCKET_HOME}/store/commitlog/，该目录下会存在多个内存映射文件（MappedFile）

1）String storePath：存储目录。

2）int mappedFileSize：单个文件的存储大小。

3）CopyOnWriteArrayList<MappedFile> mappedFiles:MappedFile文件集合。

4）AllocateMappedFileService allocateMappedFileService：创建MappedFile服务类。

5）long flushedWhere = 0：当前刷盘指针，表示该指针之前的所有数据全部持久化到磁盘。

6）long committedWhere = 0：当前数据提交指针，内存中ByteBuffer当前的写指针，该值大于等于flushedWhere

根据消息偏移量offset查找MappedFile。根据offet查找MappedFile直接使用offset%-mapped FileSize是否可行？答案是否定的，由于使用了内存映射，只要存在于存储目录下的文件，都需要对应创建内存映射文件**，如果不定时将已消费的消息从存储文件中删除，会造成极大的内存压力与资源浪费，所有RocketMQ采取定时删除存储文件的策略**，也就是说在存储文件中，第一个文件不一定是00000000000000000000，因为该文件在某一时刻会被删除，故根据offset定位MappedFile的算法为（int）（（offset / this.mappedFileSize）-（mappedFile.getFileFromOffset（）/ this.MappedFileSize））。

**获取存储文件的最大偏移量**。返回最后一个MappedFile文件的fileFromOffset加上MappedFile文件当前的写指针。

### 4.2 MappedFile内存映射文件

**1．MappedFile初始化**

根据是否开启transientStorePoolEnable存在两种初始化情况。transientStorePoolEnable为true表示内容先存储在堆外内存，然后通过Commit线程将数据提交到内存映射Buffer中，再通过Flush线程将内存映射Buffer中的数据持久化到磁盘中。

**2．MappedFile提交(commit)**

存映射文件的提交动作由MappedFile的commit方法实现

ByteBuffer使用技巧：slice（）方法创建一个共享缓存区，与原先的ByteBuffer共享内存但维护一套独立的指针（position、mark、limit）。

**3．MappedFile刷盘(flush)**

刷盘指的是将内存中的数据刷写到磁盘，永久存储在磁盘中，其具体实现由MappedFile的flush方法实现。

**4．获取MappedFile最大读指针（getReadPosition）**

RocketMQ文件的一个组织方式是内存映射文件，预先申请一块连续的固定大小的内存，需要一套指针标识当前最大有效数据的位置，获取最大有效数据偏移量的方法由MappedFile的getReadPosition方法实现

如果writeBuffer为空，则直接返回当前的写指针；如果writeBuffer不为空，则返回上一次提交的指针。在MappedFile设计中，**只有提交了的数据（写入到MappedByteBuffer或FileChannel中的数据）才是安全的数据。**

5．MappedFile销毁(destory)

MappedFile文件销毁的实现方法为public boolean destroy（final long intervalForcibly）,intervalForcibly表示拒绝被销毁的最大存活时间。

- Step1：关闭MappedFile。
- Step2：判断是否清理完成，判断标准是引用次数小于等于0并且cleanupOver为true,cleanupOver为true的触发条件是release成功将MappedByteBuffer资源释放。
- Step3：关闭文件通道，删除物理文件。

**在整个MappedFile销毁过程，首先需要释放资源，释放资源的前提条件是该Mapped-File的引用小于等于0**



### 4.4.3 TransientStorePool

TransientStorePool：短暂的存储池。RocketMQ单独创建一个MappedByteBuffer内存缓存池，用来临时存储数据，数据先写入该内存映射中，然后由commit线程定时将数据从该内存复制到与目的物理文件对应的内存映射中。RokcetMQ引入该机制主要的原因是提供一种内存锁定，将当前堆外内存一直锁定在内存中，避免被进程将内存交换到磁盘。

1）int poolSize:avaliableBuffers个数，可通过在broker中配置文件中设置transient-StorePoolSize，默认为5。2）int fileSize：每个ByteBuffer大小，默认为mapedFileSizeCommitLog，表明Tran s-ientStorePool为commitlog文件服务。

3）Deque<ByteBuffer> availableBuffers:ByteBuffer容器，双端队列。

