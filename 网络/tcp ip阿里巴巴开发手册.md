### 网络协议

TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协 议／因特网互联协议。

![tcp ip协议分层架构](.\pic\tcp ip协议分层架构.png)

- 链路层：单个 0、 l 是没有意义的，链路层以字节为单位把 0 与 l 进行分组， 定义**数据帧**，写入源和目标机器的物理地址、数据、校验位来传输数据。图 1-12 所示是以太网的帧协议。
- 网络层： 根据 IP 定义网络地址，区分**网段**(子网掩码)。**子网内根据地址解析协议（ ARP ) 进行 MAC 寻址**， 子网外进行路由转发数据包，这个数据包即 IP 数据包。 
- 传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻 辑端口 ， 确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是 UDP 和 TCP。 UDP 只是在 IP 数据包上增加端口等部分 信息 ， **是面向无连接的**，是不可靠传输，多用于视频通信、电话会议等（即 使少一帧数据也无妨）。与之相反 ， **TCP 是面向连接的**。所谓面向连接 ， 是 一种**端到端间通过失败重传机制建立的可靠数据传输方式**，给人感觉是有一 条固定的通路承载着数据的可靠传输。 
- 应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。比如 ， E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是 都能够读取邮件内容 ， 是因为 SMTP 协议就像传统的书信恪式一样，按规定 填写邮编及收信人信息。

![链路层报文结构](.\pic\链路层报文结构.png)

程序在发送消息时，应用层接既定的协议打包数据 ， 随后由传输层加上双方的端口号，由网络层加上双方的 IP 地址，由链路层加上双方的 MAC 地址 ， 并 将数据拆分成数据帧 ， 经过多个路由器和网关后， 至lj达目标机器。简而言之 ， 就是按 “**端口→ IP 地址→ MAC 地址**” 这样的路径进行数据的封装和发送 ， 解包的时候反过 来操作即可。

## IP 协议

IP 是面**向无连接、无状态的**，没有额外的机制保证发送的包是否有序到达。IP首先规定出 IP 地址格式，该地址相当于在逻辑意义上进行了 **网段的划分**，给每台计 算机额外设置了一个唯一的详细地址。

**IP 地址属于网络层，主要功能在 WLAN 内进行路由寻址，选择最佳路由。**

![ip报文格式](.\pic\ip报文格式.png)

数据包的生存时间，即 TTL，它是数据包可经 过的最多路由器总数(经过一个路由器 TTL 值则减 l ，当该字段为 0 时，数据包被丢弃,并发送 ICMP 报文通知 源主机，以防止源主机无休止地发送报文).ICMP ( Internet Control Message Protocol ），它是**检测传输网络是否通畅、主机是否可达、路由是否可用等网 络运行状态的协议**。 ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重 要，经常使用的 ping 、 tracert 命令就是基于 ICMP 检测网络状态的有力工具

### TCP建立连接

传输控制协议（ Transmission Control Protocol, TCP ），是 种面向连接、确保 数据在端到端间可靠传输的协议。

为了确保数据的可靠传输，不 仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时 情况时进行重传，还需要通过实现**滑动窗口和拥塞控制**等机制，避免网络状况恶化而 最终影响数据传输的极端情形。

每个 TCP 数据包是封装在 IP 包中的，每个 头的 后面紧接着的是 TCP 头。

TCP 报文格式：



![tcp报文格式](.\pic\tcp报文格式.png)

**这两个端口号与 IP 报头中的源 E 地址和目标 IP 地址所组成的囚元组可唯一标识一条 TCP 连接**。由于 TCP 是面向连接的，因此有服务端和客户端之分。需要**服务端先在 相应的端口上进行监昕，准备好接收客户端发起的建立连接请求**。当客户端发起第 个请求建立连接的 TCP 包时，目标机器端口就是服务端所监昕的端口号。比如一些 由国际组织定义的广为人知端口号一一代表 HTTP 服务的 80 端口、代表 SSH 服务的 22 端口、代表 HTTPS 服务的 443 端口。可通过 netstat 命令列出机器上已建立的连接 信息，其中包含唯标识条连接的四元组。

SYN ( Synchronize Sequence Numbers ）用作建立连接时的同步信号 ；

ACK ( Acknowledgement ）用于对 收到的数据进行确认，所确认的数据由确认序列号表示； 

FIN ( Finish ）表示后面没有 数据需要发送，通常意昧着所建立的连接需要关闭了。

三次握手指的 是建立连接的三个步骤：

- A 机器发出一个数据包并将 SYN 置 1 ，表示希望建立连接。这个包中的序列 号假设是x。

- B 机器收到 A 机器发过来的数据包后，通过 SYN 得知这是一个建立连接的 请求，于是发送一个响应包并将 SYN 和 ACK 标记都置 1。假设这个包中的 序列号是 y，而确认序列号必须是 x+l ，表示收到了 A 发过来的 SYN。 在 TCP 中， SYN 被当作数据部分的一个字节。

- A 收到 B 的响应包后需进行确认，确认包中将 ACK 置 1，并将确认序列号 设置为 y+ l ，表示收到了来自 B 的 SYN。

  ![tcp3次连接](C:\Users\dzk\Desktop\git biji\note\网络\pic\tcp3次连接.png)

这里为什么需要第 3 次握手？它有两个主要目的 **信息对等和防止超时**。先从信 息对等角度来看，如表 1 -6 所示，双方只有确定 4 类信息，才能建立连接。在第 2 次 握手后， 从 B 机器视角看还有两个红色的 NO 信息无法确认。在第 3 次握手后， B 机 器才能确认自己的发报能力和对方的收报能力是正常的。![TCP三次握手确认信息](C:\Users\dzk\Desktop\git biji\note\网络\pic\TCP三次握手确认信息.png)

连接三次握手也是防止出现请求超时导致脏连接。 **TTL 网络报文的生存时间往往都会超过 TCP 请求超时时间** ， 如果两次握手就可以创建连接 ， 传输数据并释放连 接后 ， 第一个超时的连接请求才到达 B 机器的话， B 机器会以为是 A 创建新连接的 请求 ， 然后确认同意创建连接。因为 A 机器的状态不是 SYN_ SENT ， 所以直接丢弃 了 B 的确认数据 ， 以致最后只是 B 机器单方面创建连接完毕.![两次握手导致的TCP脏连接](C:\Users\dzk\Desktop\git biji\note\网络\pic\两次握手导致的TCP脏连接.png)

TCP 在协议层面支持 Keep Alive 功能，即**隔段时间通过向对方发送数据表示连 接处于健康状态**。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳 包检查连接的健康度。一旦心跳包出现异常不仅会主动关闭连接，还会回收与连接相 关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。

### TCP 断开连接

**TCP 是全双工通信**，双方都能作为数据的发送方和接收方，但 TCP 连接也会有 断开的时候。所谓相爱容易分手难，建立连接只有三次，而晖于断开则需要四次，如 图 1 -23 所示。 A 机器想要关闭连接，则待本方数据发送完毕后，传递 FIN 信号给 B 机器。 B 机器应答 ACK，告诉 A 机器可以断开，但是需要等 B 机器处理完数据，再 主动给 A 机器发送 FIN 信号。这时， A 机器处于半关闭状态（ FIN WAIT 2 ），无法 再发送新的数据。 B 机器做好连接关闭前的准备工作后，发送 FIN 给 A 机器，此时 B 机器也进入半关闭状态（ CLOSE_ WAIT）。 A 机器发送针对B 机器 FIN 的 ACK 后， 进入 TIME-WAIT 状态，经过 2MSL ( Maximum Segment Lifetime ）后，没有收到 B 机器传来的报文，贝lj确定 B 机器已经收到 A机器最后发送的 ACK 指令，此时 TCP 连接正式释放。

![TCP四次挥手断开连接](C:\Users\dzk\Desktop\git biji\note\网络\pic\TCP四次挥手断开连接.png)

 TIME_WAIT 和 CLOSE_WAIT 分别表示主动关闭和 被动关闭产生的阶段性状态，如果在线上服务器大量出现这两种状态，就会加重机器 负载，也会影响有效连接的创建，因此需要进行有针对性的调优处理。

- TIME_WAIT ： 主动要求关闭的机器表示收到了对方的 FIN 报文，并发送出 了 ACK 报文，进入 TIME WAIT 状态，等 2MSL 后即可进入到 CLOSED 状 态。如果 FIN WAIT I 状态下，同时收到带 FIN 标志和 ACK 标志的报文肘， 可以直接进入 TIME WAIT 状态，而无须经过 FIN WAIT 2 状态。
- CLOSE_WAIT： 被动要求关闭的机器收到对方请求关闭连接的 FIN 报文， 在第一次 ACK 应答后，马上进入 CLOSE WAIT 状态。这种状态其实表示在 等待关闭，并且通知应用程序发送剩余数据，处理现场信息，关闭相关资源。

在 TIME WAIT 等待的 2MSL 是报文在网络上生存的最长时间，超过阁值便将报文丢弃.**在当前的高速网络中， 2 分钟的等待时间会造成资源的极大浪费，在高并发 服务器上通常会使用更小的值**.

第 一，确认被动关闭方能够顺利进入 CLOSED 状态。如图 1-23 所示，假如最
后一个 ACK 由于网络原因导致无法到达 B 机器，处于 LAST_ACK 的 B 机器通常 “自信”地以为对方没有收到自己的 FIN+ACK 报文，所以会重发。 A机器收到第二 次的 FIN+ACK 报文，会重发一次 ACK，并且重新计时。如果 A 机器收到 B 机器的 FIN+ACK 报文后，发送个 ACK 给 B 机器，就“自私”地立马进入 CLOSED 状态， 可能会导致 B 机器无法确保收到最后的 ACK 指令，也无法进入 CLOSED 状态。这是 A 机器不负责任的表现。

第二，防止失效请求。这样做是为了防止己失效连接的请求数据包与正常连接的 请求数据包混淆而发生异常。

因为 **TIME _WAIT 状态无法真正释放旬柄资源**，在此期间， Socket 中使用的本地 端口在默认情况下不能再被使用。该限制对于客户端机器来说是无所谓的，但对于高 并发服务器来说，会极大地限制有效连接的创建数量，成为性能瓶颈。所以，建议将 高并发服务器 TIME WAIT 超时时间调小。(小于30秒为宜)

