### 网络协议

TCP/IP ( Transmission Control Protocol I Internet Protocol ）中文译为传输控制协 议／因特网互联协议。

![tcp ip协议分层架构](.\pic\tcp ip协议分层架构.png)

- 链路层：单个 0、 l 是没有意义的，链路层以字节为单位把 0 与 l 进行分组， 定义**数据帧**，写入源和目标机器的物理地址、数据、校验位来传输数据。图 1-12 所示是以太网的帧协议。
- 网络层： 根据 IP 定义网络地址，区分**网段**(子网掩码)。**子网内根据地址解析协议（ ARP ) 进行 MAC 寻址**， 子网外进行路由转发数据包，这个数据包即 IP 数据包。 
- 传输层： 数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻 辑端口 ， 确认身份后，将数据包交给应用程序，实现端口到端口间通信。最典型的传输层协议是 UDP 和 TCP。 UDP 只是在 IP 数据包上增加端口等部分 信息 ， **是面向无连接的**，是不可靠传输，多用于视频通信、电话会议等（即 使少一帧数据也无妨）。与之相反 ， **TCP 是面向连接的**。所谓面向连接 ， 是 一种**端到端间通过失败重传机制建立的可靠数据传输方式**，给人感觉是有一 条固定的通路承载着数据的可靠传输。 
- 应用层： 传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据。比如 ， E-mail 在各个公司的程序界面、操作、管理方式都不一样，但是 都能够读取邮件内容 ， 是因为 SMTP 协议就像传统的书信恪式一样，按规定 填写邮编及收信人信息。

![链路层报文结构](.\pic\链路层报文结构.png)

程序在发送消息时，应用层接既定的协议打包数据 ， 随后由传输层加上双方的端口号，由网络层加上双方的 IP 地址，由链路层加上双方的 MAC 地址 ， 并 将数据拆分成数据帧 ， 经过多个路由器和网关后， 至lj达目标机器。简而言之 ， 就是按 “**端口→ IP 地址→ MAC 地址**” 这样的路径进行数据的封装和发送 ， 解包的时候反过 来操作即可。

## IP 协议

IP 是面**向无连接、无状态的**，没有额外的机制保证发送的包是否有序到达。IP首先规定出 IP 地址格式，该地址相当于在逻辑意义上进行了 **网段的划分**，给每台计 算机额外设置了一个唯一的详细地址。

**IP 地址属于网络层，主要功能在 WLAN 内进行路由寻址，选择最佳路由。**

![ip报文格式](.\pic\ip报文格式.png)

数据包的生存时间，即 TTL，它是数据包可经 过的最多路由器总数(经过一个路由器 TTL 值则减 l ，当该字段为 0 时，数据包被丢弃,并发送 ICMP 报文通知 源主机，以防止源主机无休止地发送报文).ICMP ( Internet Control Message Protocol ），它是**检测传输网络是否通畅、主机是否可达、路由是否可用等网 络运行状态的协议**。 ICMP 虽然并不传输用户数据，但是对评估网络健康状态非常重 要，经常使用的 ping 、 tracert 命令就是基于 ICMP 检测网络状态的有力工具

### TCP建立连接

传输控制协议（ Transmission Control Protocol, TCP ），是 种面向连接、确保 数据在端到端间可靠传输的协议。

为了确保数据的可靠传输，不 仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时 情况时进行重传，还需要通过实现**滑动窗口和拥塞控制**等机制，避免网络状况恶化而 最终影响数据传输的极端情形。

每个 TCP 数据包是封装在 IP 包中的，每个 头的 后面紧接着的是 TCP 头。

TCP 报文格式：



![tcp报文格式](.\pic\tcp报文格式.png)

**这两个端口号与 IP 报头中的源 E 地址和目标 IP 地址所组成的囚元组可唯一标识一条 TCP 连接**。由于 TCP 是面向连接的，因此有服务端和客户端之分。需要**服务端先在 相应的端口上进行监昕，准备好接收客户端发起的建立连接请求**。当客户端发起第 个请求建立连接的 TCP 包时，目标机器端口就是服务端所监昕的端口号。比如一些 由国际组织定义的广为人知端口号一一代表 HTTP 服务的 80 端口、代表 SSH 服务的 22 端口、代表 HTTPS 服务的 443 端口。可通过 netstat 命令列出机器上已建立的连接 信息，其中包含唯标识条连接的四元组。

SYN ( Synchronize Sequence Numbers ）用作建立连接时的同步信号 ；

ACK ( Acknowledgement ）用于对 收到的数据进行确认，所确认的数据由确认序列号表示； 

FIN ( Finish ）表示后面没有 数据需要发送，通常意昧着所建立的连接需要关闭了。

三次握手指的 是建立连接的三个步骤：

- A 机器发出一个数据包并将 SYN 置 1 ，表示希望建立连接。这个包中的序列 号假设是x。

- B 机器收到 A 机器发过来的数据包后，通过 SYN 得知这是一个建立连接的 请求，于是发送一个响应包并将 SYN 和 ACK 标记都置 1。假设这个包中的 序列号是 y，而确认序列号必须是 x+l ，表示收到了 A 发过来的 SYN。 在 TCP 中， SYN 被当作数据部分的一个字节。

- A 收到 B 的响应包后需进行确认，确认包中将 ACK 置 1，并将确认序列号 设置为 y+ l ，表示收到了来自 B 的 SYN。

  ![tcp3次连接](C:\Users\dzk\Desktop\git biji\note\网络\pic\tcp3次连接.png)

这里为什么需要第 3 次握手？它有两个主要目的 **信息对等和防止超时**。先从信 息对等角度来看，如表 1 -6 所示，双方只有确定 4 类信息，才能建立连接。在第 2 次 握手后， 从 B 机器视角看还有两个红色的 NO 信息无法确认。在第 3 次握手后， B 机 器才能确认自己的发报能力和对方的收报能力是正常的。![TCP三次握手确认信息](C:\Users\dzk\Desktop\git biji\note\网络\pic\TCP三次握手确认信息.png)

连接三次握手也是防止出现请求超时导致脏连接。 **TTL 网络报文的生存时间往往都会超过 TCP 请求超时时间** ， 如果两次握手就可以创建连接 ， 传输数据并释放连 接后 ， 第一个超时的连接请求才到达 B 机器的话， B 机器会以为是 A 创建新连接的 请求 ， 然后确认同意创建连接。因为 A 机器的状态不是 SYN_ SENT ， 所以直接丢弃 了 B 的确认数据 ， 以致最后只是 B 机器单方面创建连接完毕.![两次握手导致的TCP脏连接](C:\Users\dzk\Desktop\git biji\note\网络\pic\两次握手导致的TCP脏连接.png)

TCP 在协议层面支持 Keep Alive 功能，即**隔段时间通过向对方发送数据表示连 接处于健康状态**。不少服务将确保连接健康的行为放到了应用层，通过定期发送心跳 包检查连接的健康度。一旦心跳包出现异常不仅会主动关闭连接，还会回收与连接相 关的其他用于提供服务的资源，确保系统资源最大限度地被有效利用。